<html>
<head>
	<title>Sleep 2019 | Lesley Huang</title>
	<meta charset="UTF-8">
	<script src="https://d3js.org/d3.v5.min.js"></script>
	<script src="//unpkg.com/d3-radial-axis"></script>
	<link href="https://fonts.googleapis.com/css?family=Inconsolata&display=swap" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Montserrat:200,200i&display=swap" rel="stylesheet">
</head>
<body bgcolor= "#fbfbfb" style="display: flex; flex-direction: column; text-align: center; margin-bottom: 20px;">
		<h2 style="font-family: 'Inconsolata', monospace; padding-top: 50px; font-size: 40px;">Sleep patterns of 2019</h2>
		<div style="margin: 0 auto; width: 900; font-family: 'Montserrat', sans-serif; font-size: 0.8vw; text-align: left;">
			<h3>I started collecting data on my sleep habits about 3 years ago when I noticed that my sleep schedule was becoming increasingly
			irregular. I had thought that by seeing my sleep patterns fall into disarray in real time I would make a conscious effort to correct it. Many of my close friends were aware that I slept at weird times but I don't think they knew, or even I knew, the severity of my sleep habits.</h3>
			<h3>And yet, here we are, 3 years later. I realized that sleep will always be something that I struggle to value, but I'm working on prioritizing it for the upcoming year.</h3>
			<h3>Here's to more zzz's in 2020! üëè</h3>
		</div>

		<div>
			<svg id="bar" height="625" width="1100"/>
			<div style="margin-top: 20px; margin-bottom: 10px;">
				<div id="stats" style="text-align: left; font-family: 'Montserrat', sans-serif; font-size: 0.8vw; display: inline-block; border: 1px solid #cdcdcd; border-radius: 5px; padding: 10px; margin-bottom: 10px; opacity: 0;"></div>
			</div>
		</div>

		<div style="margin: 0 auto; width: 900; font-family: 'Montserrat', sans-serif; font-size: 0.8vw; text-align: left;">
			<h3>Based on the heat map, it is evident that working a 9-5 job during the summer forced me to sleep earlier. I also woke up later during the spring because my first class of the day started after noon. Unfortunately, I didn't have the same luck in the fall where my earliest class started at 8:40am (never again üò≠). </h3>
			<h3>The ranges show the times where the probability of me being asleep is at least 50% (~15 days of the month). It's interesting to note that there are <b>no</b> time ranges where I am guaranteed to be asleep for 100% of that month and hour. </h3>
		</div>

		<div style="padding-top: 30px; padding-left: 150px;">
			<svg id="heatMap" height="550" width="1050"/>
		</div>

		<div style="margin: 0 auto; width: 900; font-family: 'Montserrat', sans-serif; font-size: 0.8vw; text-align: left; ">
			<h3>I took very different classes during my spring and fall semesters at university which, evidently, affected my sleep quite drastically. While I generally slept later in the spring, my sleep schedule was surprisingly more consistent. You can also catch glimpses of when my tendencies to sleep late relasped in the fall, which causes the arcs to shift clockwise.</h3>
			<h3>The cycle represents a 24 hour clock and each ring represents a singular day, starting from the center and growing outwards.</h3>
		</div>

		<div style="display: flex; flex-direction: row; justify-content: space-around; margin: auto;" width="1100" >
			<div style="text-align: center;">
				<h3 style="font-family: 'Inconsolata', monospace; font-size: 1.5vw;">Sophomore Spring 2019</h3>
				<h3 style="font-family: 'Montserrat', sans-serif; font-size: 0.9vw;">January 24 - May 18</h3>
				<svg id="pie_spring" height="550" width="550"/>
				<div style="font-family: 'Montserrat', sans-serif; font-size: 0.8vw; display: inline-block; border: 1px solid #cdcdcd; border-radius: 5px; padding: 10px; text-align: left;" id="pie_spring_stats"><b>stats</b> spring</div>
			</div>
			<div style="text-align: center;">
				<h3 style="font-family: 'Inconsolata', monospace; font-size: 1.5vw;">Junior Fall 2019</h3>
				<h3 style="font-family: 'Montserrat', sans-serif; font-size: 0.9vw;">August 29 - December 21</h3>
				<svg id="pie_fall" height="550" width="550"/>
				<div style="font-family: 'Montserrat', sans-serif; font-size: 0.8vw; display: inline-block; border: 1px solid #cdcdcd; border-radius: 5px; padding: 10px; text-align: left;" id="pie_fall_stats">stats fall</div>
			</div>
		</div>
	</div>
	<script>		
		let PI = Math.PI;
		let arcMin = 25;
		let arcWidth = 1.5;
		var sleepData, heatMapData;
		var fullAwakeArr = [];

		var margin = {top: 0, right: 0, bottom: 50, left: 0},
		    width = 500 - margin.left - margin.right,
		    height = 2000 - margin.top - margin.bottom;

		let padding = 50;
		var isAllNight, isMinMax, isStats = false;
		var isHMStats, isHMNotes, isHMMinmax = false;

		const monthNames = ["January", "February", "March", "April", "May", "June",
		  "July", "August", "September", "October", "November", "December"
		];


		// convert string of times into array
		function splitDayData(str) {
			return str.split(";").map(s => s.trim());
		}

		Date.prototype.getDOY = function() {
		    var dayCount = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
		    var mn = this.getMonth();
		    var dn = this.getDate();
		    var dayOfYear = dayCount[mn] + dn;
		    return dayOfYear;
		};

		function convertTimeToFrac(str) {
			switch(str) {
				case "00":
					return "0";
					break;
				case "15":
					return "25";
					break;
				case "30":
					return "50";
					break;
				case "45":
					return "75";
					break;
				default:
					break;
			}
		}

		// convert time to value on pie
		function stringToPie(str) {
			var str = str.split(":");
			return parseFloat(str[0] + "." + convertTimeToFrac(str[1]));
		}

		// total hours slept per day 
		function calculateTotalHours(str) {
			var times = str.split(";");
			var total = 0;
			for (var v in times) {
				var time = times[v].split("-");
				total += stringToPie(time[1]) - stringToPie(time[0]);
			}
			return total;
		}

		// format: xx h xx min
		function convertNumToTimeDec(num) {
			var hrs = Math.floor(num);
			var mins = Math.floor(num * 60 % 60);

			return hrs + " h " + mins + " min";
		}

		// format: xx:xx am (assuming that all times are < 12p)
		function convertNumToTimeStr(num) {
			var hrs = Math.floor(num);
			var mins = Math.floor(num * 60 % 60);

			return hrs + ":" + mins + " am";
		}

		function getLongestTimeSegment(str) {
			var length = 0;
			var timeStr = "";

			var timeBlock = (str.split(";"));

			for (var i = 0; i < timeBlock.length; i++) {
				var time = timeBlock[i].split("-");	
				if (stringToPie(time[0]) < 12) {
					var tempLength = stringToPie(time[1]) - stringToPie(time[0]);

					if (tempLength > length) {
						length = tempLength;
						timeStr = timeBlock[i];
					}
				}
			}

			return timeStr;
		}
		// get avg time to fall asleep
		function getAvgSleepTime(data) {
			var total = 0;
			var count = 0;
			for (var i = 0; i < data.length; i++) {
				var str = data[i]["times"];
				var timeBlock = getLongestTimeSegment(str).split(";");
				// var timeBlock = (str.split(";"));
				if (timeBlock != "") {
					var sleepTime = (timeBlock[0].split("-"))[0];
					total += stringToPie(sleepTime);
					count ++;
				} 
				// else {
				// 	console.log(data[i]);
				// }
			}
			return total/count;
		}

		function getAllNighters(data) {
			var finalList = [];
			for (var i = 0; i < data.length; i++) {
				var str = data[i]["times"]
				var timeBlock = (str.split(";"));
				var time = timeBlock[0].split("-");

				// did not sleep before 12
				if (stringToPie(time[0]) > 12) {
					finalList.push(data[i]);
				}
				// napped btw 12-2a, but did not sleep afterwards until 12p 
				else if (timeBlock.length > 1) {
					if (stringToPie(time[0]) < 3 && stringToPie(time[1]) < 2 && stringToPie(timeBlock[1].split("-")[0]) > 12) {
						finalList.push(data[i]);
					}
				} else {
					if (stringToPie(time[0]) < 3 && stringToPie(time[1]) < 2) {
						finalList.push(data[i]);
					}
				}

			}
			return finalList;
		} 

		function calculateStdDev(data, avg) {
			var totalSd = 0;
			for (var i = 0; i < data.length; i++) {
				var arr = splitDayData(data[i]["times"]);
				var durationPerDay = arr.reduce(function(sum, value) {
					return sum + stringToPie(value.split("-")[1]) - stringToPie(value.split("-")[0]);
				}, 0);

				totalSd = totalSd + Math.pow((durationPerDay - avg), 2);

				// var squDiff = arr.map(x => {
				// 	var cd = stringToPie(x.split("-")[1]) - stringToPie(x.split("-")[0]);
				// 	var sd = Math.pow((cd - avg), 2);
				// 	console.log(cd);
				// 	return sd;
				// });
			}

			return Math.sqrt(totalSd)/data.length;
		}

		function getMinMax(data) {
			var maxCount = 0;
			var maxDate, minDate;
			var minCount = 100;

			for (var i = 0; i < data.length; i++) {
				// get max and min dates
				if (calculateTotalHours(data[i]["times"]) > maxCount) {
					maxCount = calculateTotalHours(data[i]["times"]);
					maxDate = data[i];
				}

				if (calculateTotalHours(data[i]["times"]) < minCount) {
					minCount = calculateTotalHours(data[i]["times"]);
					minDate = data[i];
				}

			}
			return [minDate, maxDate];
		}

		function mapToHeatMapFormat(data) {
			var newMap = [];
			for (var i = 0; i < monthNames.length; i++) {
				var key = monthNames[i];

				for (var j = 0; j < (data[key]).length; j++) {
					newMap.push({
						"month": i,
						"time": j,
						"total": data[key][j]
					});
				} 
			}
			return newMap;
		}

		function getHeatMapData(data) {
			var totalByMonth = {};
			for (var i = 0; i < data.length; i++) {
				var timesArr = splitDayData(sleepData[i]["times"]);
				var month = monthNames[sleepData[i]["date"].split('/')[0]-1];
				if (!(month in totalByMonth)) {
					totalByMonth[month] = new Array(24).fill(0);
				}
				timesArr.map(x => {
					var endTime = stringToPie(x.split("-")[1])
					var startTime = stringToPie(x.split("-")[0])

					if (Math.floor(endTime) != 24) {
						totalByMonth[month][Math.floor(endTime)] += (endTime - Math.floor(endTime));
					} 

					for (var i = Math.floor(endTime)-1; i > Math.floor(startTime); i--) {
						totalByMonth[month][i] += 1;
					}

					totalByMonth[month][Math.floor(startTime)] += (1 - (startTime) + Math.floor(startTime));

				});			
			}
			heatMapData = mapToHeatMapFormat(totalByMonth);
		}

		function getRangeOfTime(data) {
			var start, end;
			for (var i = 0; i < data.length; i++) {
				var total = data[i]["total"];
				if (total >= 15) { // 50% of days
					if (start == null) {
						start = data[i]["time"];
						end = start;
					} else {
						end = data[i]["time"];
					}
				}
			}
			return [start, end];
		}

		const calculateData = (sleepData) => {
			// calculate avg amt of sleep per day
			var totalHours = 0;
			// naps are defined as < 3h
			var totalHoursMinusNaps = 0; 
			var shutEyeCounter = 0;

			var maxCount = 0;
			var maxDate, minDate;
			var minCount = 100;
			for (var i = 0; i < sleepData.length; i++) {
				var timesArr = splitDayData(sleepData[i]["times"]);
				timesArr.map(x => {
					var currentDuration = stringToPie(x.split("-")[1]) - stringToPie(x.split("-")[0]);
					totalHours = totalHours + currentDuration;

					// nap is defined as starting btw 12p-10p
					if (stringToPie(x.split("-")[0]) < 12.0 || stringToPie(x.split("-")[0]) >= 22.0) {
						totalHoursMinusNaps = totalHoursMinusNaps + currentDuration;
					}

					if (currentDuration >= 1.0) {
						shutEyeCounter = shutEyeCounter + 1;
					}

				});			
			}
	
			var avgPerDay = totalHours/sleepData.length;
			var avgPerDaySd = calculateStdDev(sleepData, avgPerDay);
			var avgPerDayMinusNaps = totalHoursMinusNaps/sleepData.length;
			var avgPerShutEye = totalHours/shutEyeCounter;
			// console.log("Average Hours Per Day: " + avgPerDay);
			// console.log("Average SD: " + avgPerDaySd);
			// console.log("Average Hours Per Shut Eye: " + avgPerShutEye);
			// console.log("Average Hours Per Day (Minus Naps):" +  avgPerDayMinusNaps);
			// console.log("Average Sleep Time: " + getAvgSleepTime(sleepData));

			var finalText = "<b>avg time slept / day: </b>" + convertNumToTimeDec(avgPerDay.toFixed(2))
				+"<br/> <b>avg time slept / day (minus naps): </b>" +  convertNumToTimeDec(avgPerDayMinusNaps.toFixed(2))
				+ "<br/> <b>avg time slept / shut-eye: </b>" + convertNumToTimeDec(avgPerShutEye.toFixed(2))
				+ "<br/> <b>avg shut-eye time: </b>" + convertNumToTimeStr(getAvgSleepTime(sleepData).toFixed(2));

			return finalText;
		}

		const requestPieData = async () => {
			sleepData = await d3.csv("sleep.csv");
			// console.log(sleepData);
			getHeatMapData(sleepData);
			drawPie(sleepData.slice(23, 139), "#pie_spring", "sleep_spring");
			drawPie(sleepData.slice(240, 355), "#pie_fall", "sleep_fall");
			drawBarChart();
			drawHeatMap(heatMapData);
		};

		// creates array for awake times 
		function addAwakeTime(obj) {
			var timeStr = obj["times"].split(";").map(x => x.trim());
			var awakeArr = [];
			for (var i = 0; i < timeStr.length; i++) {
				// time range is not the last one
				if (i + 1 != timeStr.length) {
					awakeArr.push(timeStr[i].split("-")[1] + "-" + timeStr[i+1].split("-")[0]);
				} else {
					if (timeStr[i].substring(5, 11) != "24:00") {
						awakeArr.push(timeStr[i].split("-")[1] + "-24:00");
					}
				}
			}

			if (timeStr[0].substring(0, 4) != "00:00") {
				awakeArr.push("00:00-" + timeStr[0].split("-")[0]);
			}

			var newObj = {
				'date': obj["date"],
				'times': awakeArr.join(";")
			};
			fullAwakeArr.push(newObj);
		}

		requestPieData();

		function drawPie(data, pie_id, class_name) {
			var ringCounter = 0;
			// arc generator for each time
			var arc = d3.arc()
				.startAngle(function(d) {
					var str = d.split("-");
					return (stringToPie(str[0])/24 * 360 * PI / 180);
				})
				.endAngle(function(d) {
					var str = d.split("-");
					return (stringToPie(str[1])/24 * 360 * PI / 180);
				})
				.innerRadius(function(d, i) {
					if (i == 0) ringCounter += 1;
					return arcMin + ringCounter*arcWidth;
				})
				.outerRadius(function(d, i) {
					return arcMin + (ringCounter+1)*arcWidth;
				});

			let sleepSvg = d3.select(pie_id)
				.append('g')
				.attr('class', class_name);

			let allRings = sleepSvg.selectAll('g.' + class_name)
				.data(data)
				.enter();

			var sleepPaths = allRings.selectAll('path')
				.data(function (d, i) { 
					addAwakeTime(d);
					return splitDayData(d['times']); 
				})
				.enter()
				.append('path')
				.attr('d', arc)
				.attr('transform', "translate(" + 275 + ", " + 275 + ")") // make sure to edit these values
				.attr('fill', "#7DB8E8");

			// reset ring counter for awake data
			var ringCounter = 0;

			let awakeSvg = d3.select(pie_id)
				.append('g');

			let allAwakeRings = awakeSvg.selectAll('g.' + class_name)
				.data(fullAwakeArr)
				.enter();

			var awakePaths = allAwakeRings
				.selectAll('path')
				.data(function (d, i) { 
					return splitDayData(d['times']); 
				})
				.enter()
				.append('path')
				.attr('d', arc)
				.attr('transform', "translate(" + 275 + ", " + 275 + ")") // make sure to edit these values
				.attr('fill', "#e7e7e7");

			// draw x-axis
			var axisScale = d3.scaleLinear()
				.domain([0, 24])
				.range([0, 2*Math.PI]);

			d3.select(pie_id)
				.append('g')
				.call(d3.axisRadialOuter(
					axisScale, 
					arcMin + (ringCounter+5)*arcWidth)
				.tickFormat(function(d) {
					if (d == "24") return "";
					return d + ":00";
				})
				).attr('transform', "translate(" + 275 + ", " + 275 + ")") // make sure to edit these values
				.style("opacity", 0.6)
				.selectAll("text")
					.style("font-family", "Inconsolata")
			        .style("font-size", "0.8vw")
			        .attr("text-anchor", function(d) {
			        	if (axisScale(d) < Math.PI) return "start";
			        	else return "end";
			        });				

			fullAwakeArr = [];

			d3.select(pie_id)
            	.append('text')
            	.attr('transform', "translate(" + 275 + ", " + 30 + ")") // make sure to edit these values
            	.text("time ü†í")
            	.style("font-family", "Inconsolata")
		        .style("font-size", "0.8vw")
		        .style("font-weight", "bold");

			d3.select(pie_id + "_stats")
				.html(calculateData(data));
		}

		// flatten nested map
		function modifyDataForBar(data) {
			var temp = [];
			for (var d in data) {
				// haha too lazy to fix this bug
				if (data[d][0] != "date") {
					var times = splitDayData(data[d].times);
					for (var t in times) {
						var str = times[t].split("-");
						var item = {
							"date": data[d].date,
							"time": [stringToPie(str[0]), stringToPie(str[1])]
						}
						temp.push(item);
					}
				}
			}
			
			return temp;
		}

		function drawBarChart() {
			let barSvg = d3.select('#bar')
				.append('g')
				.attr("transform", "translate(0, 50)");
			let barData = modifyDataForBar(sleepData);

			var x = d3.scaleTime()
				.domain([new Date(barData[0]["date"]), new Date(barData[barData.length - 1]["date"])])
				.range([0+padding, 1100-padding-20]);

			var y = d3.scaleLinear()
				.domain([0, 24])
				.range([padding, 500]);

			d3.select("#bar")
            	.append('text')
            	.attr("transform", "translate(40, 40)")
            	.text("Sleep by Day")
            	.style("font-family", "Inconsolata")
		        .style("font-size", "1.5vw")
		        .style("font-weight", "bold");

			// add bars for all nights 
			var allNighterList = getAllNighters(sleepData);
			barSvg.selectAll('.allNighter')
				.data(allNighterList)
				.enter()
				.append('rect')
				.attr('class', 'allNighter')
				.attr('x', function(d, i) { return x(new Date(d.date));})
				.attr('y', function() { return y(0);})
				.attr('width', 1.5)
				.attr('height', 500-padding)
				.attr('fill', '#FFAF66')
				.style("opacity", 0);

			// add main bars to graph
			barSvg.selectAll(".main_bars")
				.data(barData)
				.enter()
				.append("rect")
				.attr('class', 'main_bars')
				.attr("id", function(d) {
					var temp = (d.date).split("/");
					return "bar_" + temp[0] + "_" + temp[1];
				})
				.attr("x", function(d, i) {
					return x(new Date(d.date))
				})
				.attr("y", function(d, i) {
					return y(d.time[0]);
				})
				.attr("width", 1.5)
				.attr("height", function(d, i) {
					// console.log((d.time[1] - d.time[0]))
					return y(d.time[1]) - y(d.time[0]);
				})
				.attr("fill", "#7DB8E8");

			// create min/max tooltips
			var minMaxList = getMinMax(sleepData);
			barSvg.selectAll("#minMaxCircle")
				.data(minMaxList)
				.enter()
				.append('circle')
				.attr('class', 'minmax')
				.attr('cx', function(d) {return x(new Date(d.date))+0.75;}) // add offset of rect_width/2
				.attr('cy', 500)
				.attr('r', 5)
		    	.style('stroke', '#cdcdcd')
		    	.style('stroke-width', 2)
		    	.style('fill-opacity', 0)
		    	.style('opacity', 0);

		    barSvg.selectAll('#minMaxLine')
		    	.data(minMaxList)
				.enter()
		    	.append('line')
		    	.attr('class', 'minmax')
		    	.attr('x1', function(d) {return x(new Date(d.date))+0.75;}) // add offset of rect_width/2
		    	.attr('x2', function(d) {return x(new Date(d.date))+0.75;}) // add offset of rect_width/2
		    	.attr('y1', 500+5)
		    	.attr('y2', 500+20)
		    	.style('stroke', '#cdcdcd')
		    	.style('stroke-width', 2)
		    	.style('opacity', 0);

		    barSvg.selectAll('#minMaxText')
		    	.data(minMaxList)
				.enter()
		    	.append('text')
		    	.attr('class', 'minmax')
		    	.attr('x', function(d) {return x(new Date(d.date))-5;})
		    	.attr('y', 500+35)
		    	.text(function(d) {
		    		var date = new Date(d.date);
		    		return monthNames[date.getMonth()] + " " + date.getDate() + ": " + calculateTotalHours(d.times) + " hours slept";
		    	})
		    	.style("font-family", "Montserrat")
	   			.style("font-size", "0.8vw")
	   			.attr("font-weight", "bold")
	   			.style('opacity', 0);

			// draw x axis
			d3.select('#bar')
				.append("g")
		        .attr("class", "x_axis")
		        .attr("transform", "translate(0," + (45+padding) +")")
		        .call(d3.axisTop(x).tickFormat(d3.timeFormat("%b")).ticks(8))
		        .style("font-family", "Inconsolata")
		        .style("font-size", "0.8vw")
		        .select(".domain").remove();

		    // draw y axis
		    d3.select('#bar')
				.append("g")
		        .attr("class", "y_axis")
		        .attr("transform", "translate(1040, 50)")
		        .call(d3.axisRight(y).tickFormat(function(d) { return d + ":00"}).ticks(8))
		        .style("font-family", "Inconsolata")
		        .style("font-size", "0.8vw")
		        .select(".domain").remove();

		    d3.select("#bar")
            	.append('text')
            	.attr('transform', "translate(" + 1090 + ", " + (45+padding) + "), rotate(90)") // make sure to edit these values
            	.text("time ü†í")
            	.style("font-family", "Inconsolata")
		        .style("font-size", "0.8vw")
		        .style("font-weight", "bold");

		    // add text for stats box
		    d3.select("#stats")
		    	.html(calculateData(sleepData));

		    // adding key for bar chart
		    let key = ["all nighters", "min / max", "stats"];

		    barSvg.selectAll('.key')
				.data(key)
		    	.enter()
		    	.append('circle')
		    	.attr('id', function(d, i) { return "key_" + i;})
		    	.attr('cx', function(d, i) { return 435 + i*100;})
		    	.attr('cy', 515 + padding)
		    	.attr('r', 8)
		    	.style('fill', '#fbfbfb')
		    	.style('stroke', '#cdcdcd')
		    	.style('stroke-width', 2)
		    	.on('click', function (d, i) {
		    		if (d == "all nighters") {
		    			if (!isAllNight) {
			    			barSvg.selectAll('.allNighter')
			    				.transition()
			    				.duration(500)
			    				.style("opacity", 1);

			    			isAllNight = true;

			    			var circle = d3.select('#key_0')
			    				.transition()
			    				.duration(500)
			    				.style('fill', '#cdcdcd');
		    			} else {
		    				barSvg.selectAll('.allNighter')
			    				.transition()
			    				.duration(500)
		    					.style("opacity", 0);

		    				isAllNight = false;

		    				var circle = d3.select('#key_0')
		    				.transition()
		    				.duration(500)
		    				.style('fill', '#fbfbfb');
		    			}
		    			
		    		} else if (d == "min / max") {
		    			if (!isMinMax) {
		    				barSvg.selectAll('.minmax')
		    					.transition()
		    					.duration(500)
		    					.style('opacity', 1);

		    				isMinMax = true;

		    				var circle = d3.select('#key_1')
		    				.transition()
		    				.duration(500)
		    				.style('fill', '#cdcdcd');
		    			} else {
		    				barSvg.selectAll('.minmax')
		    					.transition()
		    					.duration(500)
		    					.style('opacity', 0);

		    				isMinMax = false;

		    				var circle = d3.select('#key_1')
		    				.transition()
		    				.duration(500)
		    				.style('fill', '#fbfbfb');
		    			}
		    		} else if (d == "stats") {
						if (!isStats) {
		    				d3.selectAll('#stats')
		    					.transition()
		    					.duration(500)
		    					.style('opacity', 1);

		    				isStats = true;

		    				var circle = d3.select('#key_2')
		    				.transition()
		    				.duration(500)
		    				.style('fill', '#cdcdcd');
		    			} else {
		    				d3.selectAll('#stats')
		    					.transition()
		    					.duration(500)
		    					.style('opacity', 0);

		    				isStats = false;

		    				var circle = d3.select('#key_2')
		    				.transition()
		    				.duration(500)
		    				.style('fill', '#fbfbfb');
		    			}		    		
		    		}
		    	});

		    barSvg.selectAll('.key_labels')
				.data(key)
		    	.enter()
		    	.append('text')
		    	.attr('x', function(d, i) { return 450 + i*100;})
		    	.attr('y', 519+padding)
		    	.text(function(d) {return d;})
		    	.style("font-family", "Montserrat")
		    	.style("font-weight", "bold")
	   			.style("font-size", "0.8vw");
		

		    var tooltip = d3.select("body")
				.append("div")
				.style("padding", 10)
				.style("position", "absolute")
				.style("z-index", "10")
				.style("visibility", "hidden")
				.attr("white-space", "pre-line")
				.style("background-color", "#fbfbfb")
				.style("border-radius", "5px")
				.style("border", "1px solid #cdcdcd");

		    d3.select('#bar').on("mousemove", function() {
		    	var offset = document.getElementById('bar').getBoundingClientRect();

		    	// window for bar chart
		    	if (d3.event.clientX - offset.x > padding
		    		&& d3.event.clientX - offset.x <= 1100-padding-17
		    		&& d3.event.clientY - offset.y > 50 + padding 
		    		&& d3.event.clientY - offset.y < 500 + padding) {
		    		var tempDate = x.invert(d3.event.clientX - offset.x);
				// console.log(tempDate);
				d3.selectAll(".main_bars").transition()
					.duration(50)
					.style("fill", "#7DB8E8");
		    	var bars = d3.selectAll("#bar_" + (tempDate.getMonth() + 1) + "_" + tempDate.getDate());

		    	// change color of selected bars
		    	bars.transition()
    				.duration(100)
    				.style("fill", "#445578");

    			
    			var tempDay = tempDate.getDOY()-1;
    			var tooltipText = "<b>" +monthNames[tempDate.getMonth()] + " " + tempDate.getDate() + "</b>"
    				+ "<br /><b>times: </b> " + sleepData[tempDay].times
    				+ "<br /><b>total hours slept: </b>" + calculateTotalHours(sleepData[tempDay].times);

    			tooltip
	   				.html(tooltipText)
	   				.style("font-family", "Montserrat")
	   				.style("font-size", "0.8vw")
		   			.style("visibility", "visible")
		   			.style("max-width", 150)
		   			.style("top", function() {
		   				var offset = document.getElementById('bar').getBoundingClientRect();

		   				if (d3.event.clientY - offset.y < 400) {
		   					return event.pageY + 20 +"px";	
		   				} else {
		   					return event.pageY - 90 +"px";
		   				}
		   			})
		   			.style("left", function() {
		   				if (d3.event.clientX < 600) {
		   					return event.pageX + 20 +"px";	
		   				} else {
		   					return event.pageX - 150 +"px";
		   				}
		   			});
		   		} else {
		   			d3.selectAll(".main_bars").transition()
					.duration(50)
					.style("fill", "#7DB8E8");

		    		tooltip.style("visibility", "hidden");
		   		}
		    	
		    }).on("mouseleave", function () {
		    	// change color back to default
		    	d3.selectAll(".main_bars").transition()
					.duration(50)
					.style("fill", "#7DB8E8");

		    	tooltip.style("visibility", "hidden");
		    });
		}

		function drawHeatMap(data) {
			var mapWidth = 800;
			var mapheight = 500; 
			var gridSize = Math.floor((mapWidth-50) / 24) -2;
			// console.log(data);

			var colorScale = d3.scaleSequential(d3.interpolateBlues)
			  .domain([0, d3.max(data, function(d) {return d.total;})+10]);

			var heatMapSvg = d3.select("#heatMap")
				.append('g')
				.attr("transform", "translate(70, 100)");

			var tooltip = d3.select("body")
				.append("div")
				.attr("class", "heatmap_tooltip")
				.style("padding", 10)
				.style("position", "absolute")
				.style("z-index", "10")
				.style("visibility", "hidden")
				.attr("white-space", "pre-line")
				.style("background-color", "#fbfbfb")
				.style("border-radius", "5px")
				.style("border", "1px solid #cdcdcd");

			heatMapSvg.selectAll(".heatMapRect")
				.data(data)
				.enter()
				.append('rect')
				.attr("class", "heatmap_rect")
				.attr("id", function(d) {return "heatmap_" + d.month + "_" + d.time;})
				.attr("y", function(d) { return (d.month) * gridSize; })
              	.attr("x", function(d) { return (d.time) * gridSize; })
              	.attr("rx", 4)
              	.attr("ry", 4)
              	.attr("width", gridSize-5)
              	.attr("height", gridSize-5)
              	.style("fill", function(d) {return colorScale(d.total);})
              	.on("mouseover", function(d) {
              		d3.select(this)
	              		.transition()
	              		.duration(100)
	              		.style("fill", "#445578");

	              	tooltip.style("visibility", "visible");
              	})
              	.on("mouseout", function(d) {
              		d3.select(this)
              			.transition()
	              		.duration(100)
              			.style("fill", function(d) {return colorScale(d.total);});

              		tooltip.style("visibility", "hidden");
              	}).on("mousemove", function(d) {
              		var tooltipText = "<b>" + monthNames[d["month"]] + ", " + d["time"] + ":00</b>"
              			+ "<br/>" + d["total"] + " hour";

              		if (d["total"] > 1) {
              			tooltipText = tooltipText + "s";
              		}
              		
              		tooltip.html(tooltipText)
	   				.style("font-family", "Montserrat")
	   				.style("font-size", "0.8vw")
		   			.style("visibility", "visible")
		   			.style("max-width", 150)
		   			.style("top", function() {
		   				if (d["month"] < 6) {
		   					return event.pageY + 20 +"px";
		   				} else {
		   					return event.pageY - 60 +"px";
		   				}
		   			})
		   			.style("left", function() {
		   				if (d["time"] < 12) {
		   					return event.pageX + 20 +"px";
		   				} else {
		   					return event.pageX - 100 +"px";
		   				}
		   			})
              	});

            // add title
            d3.select("#heatMap")
            	.append('text')
            	.attr("transform", "translate(15, 15)")
            	.text("Breakdown by Month and Hour")
            	.style("font-family", "Inconsolata")
		        .style("font-size", "1.5vw")
		        .style("font-weight", "bold");
            
            // draw y-axis
            var y = d3.scaleBand().domain(monthNames)
            	.range([0, gridSize*12]);

            d3.select("#heatMap")
            	.append('g')
            	.attr("class", "y_axis")
            	.attr("transform", "translate(65, 100)")
                .call(d3.axisLeft(y).ticks(12).tickSize(0))
		        .style("font-family", "Inconsolata")
		        .style("font-size", "0.8vw")
		        .select(".domain").remove();

		    // draw x-axis
		    var x = d3.scaleLinear().domain([0, 23])
		    	.range([(gridSize/2)-2.5, (gridSize * 23) + (gridSize/2)-2.5]);

		    d3.select("#heatMap")
            	.append('g')
            	.attr("class", "x_axis")
            	.attr("transform", "translate(70, 95)")
                .call(d3.axisTop(x).tickFormat(function(d) { return d + ":00"}).ticks(12))
		        .style("font-family", "Inconsolata")
		        .style("font-size", "0.8vw")
		        .select(".domain").remove();

		    d3.select("#heatMap")
            	.append('text')
            	.attr("class", "x_axis")
            	.attr("transform", "translate(70, 60)")
            	.text("time ü†í")
            	.style("font-family", "Inconsolata")
		        .style("font-size", "0.8vw")
		        .style("font-weight", "bold");

		    heatMapSvg.selectAll("#heatMapBox")
		    	.data(monthNames)
		    	.enter()
		    	.append("rect")
		    		.attr("class", "heatmap_box")
		    		.attr("x", function(d, i) {
		    			var range = getRangeOfTime(data.slice(i*24, (i+1)*24));
		    			// console.log(range);
		    			return gridSize*range[0] - 2.5;
		    		})
		    		.attr("y", function(d, i) {
		    			return gridSize*i - 2.5;
		    		})
		    		.attr("width", function(d, i) {
		    			var range = getRangeOfTime(data.slice(i*24, (i+1)*24));
		    			return gridSize*(range[1] - range[0]+1);
		    		})
		    		.attr("height", gridSize)
		    		.style("fill", "none")
		    		.style("stroke-width", 2)
					.style("stroke", "#445578")
					.style("opacity", 0)
					.attr("rx", 4)
					.attr("ry", 4);	

			heatMapSvg.append("text")
				.attr("id", "heatmap_range_text")
				.attr("x", gridSize*3.5)
				.attr("y", gridSize*14.5+10)
				.text("* The ranges represent times that I've been asleep for at least 15 hours that month.")
				.attr("font-family", "Montserrat")
				.attr("font-weight", "bold")
				.attr("font-size", "0.8vw")
				.attr("opacity", 0);

			// added tooltip for notes
			heatMapSvg.append('g')
            	.attr("class", "heatmap_notes_text")
            	.attr("transform", "translate(" + (gridSize*24 + 5) + ", " + (gridSize/2 - 2.5) + ")")
                .call(d3.axisLeft(d3.scaleLinear().domain([]).range([gridSize*5, gridSize*7])).ticks(2).tickFormat(""))
                .style("opacity", 0);
            heatMapSvg.append("text")
            	.attr("class", "heatmap_notes_text")
            	.attr("x", gridSize*24 + 15)
            	.attr("y", gridSize*6 +10)	
				.text("I slept and woke up earlier")
				.attr("font-family", "Montserrat")
				.attr("font-weight", "bold")
				.attr("font-size", "0.8vw")
				.style("opacity", 0);
			heatMapSvg.append("text")
				.attr("class", "heatmap_notes_text")
            	.attr("x", gridSize*24 + 15)
            	.attr("y", gridSize*6 + 25)	
				.text("during the summer for work")
				.attr("font-family", "Montserrat")
				.attr("font-weight", "bold")
				.attr("font-size", "0.8vw")
				.style("opacity", 0);
			heatMapSvg.append('g')
            	.attr("class", "heatmap_notes_text")
            	.attr("transform", "translate(" + (gridSize*11 + 6) + ", " + (gridSize/2 - 2.5) + ")")
                .call(d3.axisLeft(d3.scaleLinear().domain([]).range([gridSize*1, gridSize*3])).ticks(2).tickFormat(""))
                .style("opacity", 0);
            heatMapSvg.append('g')
            	.attr("class", "heatmap_notes_text")
            	.attr("transform", "translate(" + (gridSize*11 + 6) + ", " + (gridSize/2 - 2.5) + ")")
                .call(d3.axisLeft(d3.scaleLinear().domain([]).range([gridSize*8, gridSize*10])).ticks(2).tickFormat(""))
                .style("opacity", 0);
            heatMapSvg.append('g')
            	.attr("class", "heatmap_notes_text")
            	.attr("transform", "translate(" + (gridSize*11 + 12) + ", " + (gridSize/2 - 2.5) + ")")
                .call(d3.axisLeft(d3.scaleLinear().domain([]).range([gridSize*2, gridSize*9])).ticks(2).tickFormat(""))
                .style("opacity", 0);
            heatMapSvg.append('path')
            	.attr("class", "heatmap_notes_text")
            	.attr("transform", "translate(" + (gridSize*11 + 13) + ", " + (gridSize/2 -2) + ")")
            	.style("stroke", "black")
            	.attr('d', ("M"+(gridSize*9) +"," + (gridSize*9) + "H" + (gridSize*12.75) + "," + 0).toString())
            	.style("opacity", 0);
            heatMapSvg.append("text")
            	.attr("class", "heatmap_notes_text")
            	.attr("x", gridSize*24 + 15)
            	.attr("y", gridSize*9 + 10)	
				.text("I woke up much later during the spring")
				.attr("font-family", "Montserrat")
				.attr("font-weight", "bold")
				.attr("font-size", "0.8vw")
				.style("opacity", 0);
			heatMapSvg.append("text")
            	.attr("class", "heatmap_notes_text")
            	.attr("x", gridSize*24 + 15)
            	.attr("y", gridSize*9 + 25)	
				.text("semester compared to the fall")
				.attr("font-family", "Montserrat")
				.attr("font-weight", "bold")
				.attr("font-size", "0.8vw")
				.style("opacity", 0);
			heatMapSvg.append('g')
            	.attr("class", "heatmap_notes_text")
            	.attr("transform", "translate(" + (gridSize*1.5) + ", " + (gridSize/2 - 2.5) + ")")
                .call(d3.axisRight(d3.scaleLinear().domain([]).range([gridSize*2, gridSize*12])).ticks(2).tickFormat("").tickSize(gridSize*4))
                .style("opacity", 0);
            heatMapSvg.append('path')
            	.attr("class", "heatmap_notes_text")
            	.attr("transform", "translate(" + (gridSize*5.5 - 1) + ", " + (gridSize/2 -2) + ")")
            	.style("stroke", "black")
            	.attr('d', ("M"+ (1) +"," + (gridSize*12) + "H" + (gridSize)).toString())
            	.style("opacity", 0);
            heatMapSvg.append("text")
            	.attr("class", "heatmap_notes_text")
            	.attr("x", gridSize*6.5 + 5)
            	.attr("y", gridSize*12 + 17)	
				.text("I slept the latest in March...must have been due to the winter weather ü§î")
				.attr("font-family", "Montserrat")
				.attr("font-weight", "bold")
				.attr("font-size", "0.8vw")
				.style("opacity", 0);

			// add tooltips for min/max tooltip
			var minMax = getHMMaxMin(data);
			heatMapSvg.append('g')
            	.attr("class", "heatmap_mm_text")
            	.attr("transform", "translate(" + (gridSize*24 + 5) + ", " + (gridSize/2 - 2.5) + ")")
                .call(
                	d3.axisLeft(
	                	d3.scaleLinear()
	                	.domain([0,1])
	                	.range([gridSize*(minMax["months"][0]), gridSize*minMax["months"][1]])
                	).ticks(2)
                	.tickFormat("")
                ).style("opacity", 0)
                .select(".domain").remove();
            heatMapSvg.append("rect")
                .attr("x", gridSize*24 - 5)
                .attr("y", gridSize*4)
                .attr("width", 20)
                .attr("height", 20)
                .style("fill", "#fbfbfb");
            heatMapSvg.append("text")
            	.attr("class", "heatmap_mm_text")
            	.attr("x", gridSize*24 + 15)
            	.attr("y", gridSize*0 + 10)	
				.text("January: " + minMax["total"][1] + " hours")
				.attr("font-family", "Montserrat")
				.attr("font-weight", "bold")
				.attr("font-size", "0.8vw")
				.style("opacity", 0);
			heatMapSvg.append("text")
				.attr("class", "heatmap_mm_text")
            	.attr("x", gridSize*24 + 15)
            	.attr("y", gridSize*0 + 25)	
				.text("(" + (minMax["total"][1]/31).toFixed(2) + " hours / day)")
				.attr("font-family", "Montserrat")
				.attr("font-weight", "bold")
				.attr("font-size", "0.8vw")
				.style("opacity", 0);
			heatMapSvg.append("text")
            	.attr("class", "heatmap_mm_text")
            	.attr("x", gridSize*24 + 15)
            	.attr("y", gridSize*8 + 10)	
				.text("September: " + minMax["total"][0] + " hours")
				.attr("font-family", "Montserrat")
				.attr("font-weight", "bold")
				.attr("font-size", "0.8vw")
				.style("opacity", 0);
			heatMapSvg.append("text")
				.attr("class", "heatmap_mm_text")
            	.attr("x", gridSize*24 + 15)
            	.attr("y", gridSize*8 + 25)	
				.text("(" + (minMax["total"][0]/31).toFixed(2) + " hours / day)")
				.attr("font-family", "Montserrat")
				.attr("font-weight", "bold")
				.attr("font-size", "0.8vw")
				.style("opacity", 0);

			
			// adding key for bar chart
		    let key = ["show ranges", "min / max", "notes"];

		    heatMapSvg.selectAll('.key')
				.data(key)
		    	.enter()
		    	.append('circle')
		    	.attr('id', function(d, i) { return "heatmap_key_" + i;})
		    	.attr('cx', function(d, i) { return 235 + i*110;})
		    	.attr('cy', gridSize*13.5)
		    	.attr('r', 8)
		    	.style('fill', '#fbfbfb')
		    	.style('stroke', '#cdcdcd')
		    	.style('stroke-width', 2)
		    	.on('click', function (d, i) {
		    		if (d == "show ranges") {
		    			if (!isHMStats) {
		    				d3.select('#heatmap_key_0')
			    				.transition()
			    				.duration(500)
			    				.style('fill', '#cdcdcd');

			    			d3.selectAll(".heatmap_box")
			    				.transition()
			    				.duration(700)
			    				.style('opacity', 1);

			    			d3.select("#heatmap_range_text")
			    				.transition()
			    				.duration(500)
			    				.style('opacity', 1);

			    		} else {
			    			d3.select('#heatmap_key_0')
			    				.transition()
			    				.duration(500)
			    				.style('fill', '#fbfbfb');

			    			d3.select("#heatmap_range_text")
			    				.transition()
			    				.duration(500)
			    				.style('opacity', 0);

			    			d3.selectAll(".heatmap_box")
			    				.transition()
			    				.duration(700)
			    				.style('opacity', 0);
			    		}
			    		isHMStats = !isHMStats;
		    		} else if (d == "notes") {
						if (!isHMNotes) {
		    				d3.select('#heatmap_key_2')
			    				.transition()
			    				.duration(500)
			    				.style('fill', '#cdcdcd');

			    			d3.selectAll(".heatmap_notes_text")
			    				.transition()
			    				.duration(700)
			    				.style("opacity", 1);

			    			if (isHMMinmax) {
			    				d3.select('#heatmap_key_1')
				    				.transition()
				    				.duration(500)
				    				.style('fill', '#fbfbfb');

			    				d3.selectAll(".heatmap_mm_text")
				    				.transition()
				    				.duration(500)
				    				.style("opacity", 0);

			    				isHMMinmax = false;
			    			}
			    		} else {
			    			d3.select('#heatmap_key_2')
			    				.transition()
			    				.duration(500)
			    				.style('fill', '#fbfbfb');

			    			d3.selectAll(".heatmap_notes_text")
			    				.transition()
			    				.duration(700)
			    				.style("opacity", 0);
			    		}
			    		isHMNotes = !isHMNotes;
		    		} else if (d == "min / max") {
		    			if (!isHMMinmax) {
		    				d3.select('#heatmap_key_1')
			    				.transition()
			    				.duration(500)
			    				.style('fill', '#cdcdcd');

			    			d3.selectAll(".heatmap_mm_text")
			    				.transition()
			    				.duration(700)
			    				.style("opacity", 1);

			    			if (isHMNotes) {
			    				d3.select('#heatmap_key_2')
				    				.transition()
				    				.duration(500)
				    				.style('fill', '#fbfbfb');

			    				d3.selectAll(".heatmap_notes_text")
				    				.transition()
				    				.duration(500)
				    				.style("opacity", 0);

			    				isHMNotes = false;
			    			}
		    			} else {
		    				d3.select('#heatmap_key_1')
			    				.transition()
			    				.duration(500)
			    				.style('fill', '#fbfbfb');

			    			d3.selectAll(".heatmap_mm_text")
			    				.transition()
			    				.duration(700)
			    				.style("opacity", 0);
		    			}
		    			isHMMinmax = !isHMMinmax;
		    		}
		    	});

		   	heatMapSvg.selectAll('.key_labels')
				.data(key)
		    	.enter()
		    	.append('text')
		    	.attr('x', function(d, i) { return 250 + i*110;})
		    	.attr('y', gridSize*13.5+4)
		    	.text(function(d) {return d;})
		    	.style("font-family", "Montserrat")
		    	.style("font-weight", "bold")
	   			.style("font-size", "0.8vw");

	   		for (var i = 0; i < monthNames.length; i++) {
	   			var month = monthNames[i];
	   			var total = 0;
	   			for (var j = 0; j < 24; j++) {
	   				total += data[i*24 + j]["total"];
	   			}
	   			// console.log(month + ": " + total);
	   		}

		}

		function getHMMaxMin(data) {
			var min = 1000;
			var max = 0;
			var minMonth, maxMonth;
			for (var i = 0; i < monthNames.length; i++) {
	   			var month = monthNames[i];
	   			var total = 0;
	   			for (var j = 0; j < 24; j++) {
	   				total += data[i*24 + j]["total"];
	   			}
	   			
	   			if (total < min) {
	   				min = total;
	   				minMonth = i;
	   			} 

	   			if (total > max) {
	   				max = total;
	   				maxMonth = i;
	   			}
	   		}

	   		return {
	   			"total" : [min, max],
	   			"months": [minMonth, maxMonth]
	   		}
		}

		
	</script>
</body>
<footer style="margin-top: 40px">
	<h3 style="font-family: 'Montserrat', sans-serif; font-size: 0.8vw;">made with üíñ and üçµ by <a href="https://www.linkedin.com/in/lesley-huang-48400/">lesley huang</a></h3>
</footer>
</html>  
